[{"path":"/opt/intel/oneapi/dev-utilities/2021.8.0/include/dpc_common.hpp", "name":"dpc_common.hpp", "has_active_debug_locs":false, "absName":"/opt/intel/oneapi/dev-utilities/2021.8.0/include/dpc_common.hpp", "content":"// Copyright (C) 2020 Intel Corporation\u000A// SPDX-License-Identifier: MIT\u000A\u000A#ifndef _DP_HPP\u000A#define _DP_HPP\u000A\u000A#include <stdlib.h>\u000A#include <exception>\u000A\u000A#include <sycl/sycl.hpp>\u000A\u000Anamespace dpc_common {\u000A// This exception handler will catch async exceptions\u000Astatic auto exception_handler = [](cl::sycl::exception_list eList) {\u000A  for (std::exception_ptr const &e : eList) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A// The TimeInterval is a simple RAII class.\u000A// Construct the timer at the point you want to start timing.\u000A// Use the Elapsed() method to return time since construction.\u000A\u000Aclass TimeInterval {\u000A public:\u000A  TimeInterval() : start_(std::chrono::steady_clock::now()) {}\u000A\u000A  double Elapsed() {\u000A    auto now = std::chrono::steady_clock::now();\u000A    return std::chrono::duration_cast<Duration>(now - start_).count();\u000A  }\u000A\u000A private:\u000A  using Duration = std::chrono::duration<double>;\u000A  std::chrono::steady_clock::time_point start_;\u000A};\u000A\u000A};  // namespace dpc_common\u000A\u000A#endif\u000A"}, {"path":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/fasta.c", "name":"fasta.c", "has_active_debug_locs":false, "absName":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/fasta.c", "content":"/* Simple API for FASTA file reading\u000A * for Bio5495/BME537 Computational Molecular Biology\u000A * SRE, Sun Sep  8 05:35:11 2002 [AA2721, transatlantic]\u000A * CVS $Id$\u000A */\u000A\u000A#include <stdlib.h>\u000A#include <stdio.h>\u000A#include <string.h>\u000A#include <ctype.h>\u000A\u000A#include \"fasta.h\"\u000A\u000A\u000A/* Function: OpenFASTA(), ReadFASTA(), CloseFASTA().\u000A * Date:     SRE, Sun Sep  8 06:39:26 2002 [AA2721, transatlantic]\u000A *\u000A * Purpose:  A very rudimentary FASTA file reading API. Designed\u000A *           for simplicity and clarity, not for robustness.\u000A *           \u000A *           The API is:\u000A *           \u000A *           ffp = OpenFASTA(seqfile);\u000A *           while (ReadFASTA(ffp, &seq, &name, &seqlen)\u000A *           {\u000A *             do stuff with sequence;\u000A *             free(name);\u000A *             free(seq);\u000A *           }\u000A *           CloseFASTA(ffp);\u000A *           \u000A * Args:     \u000A *           seqfile   - name of a FASTA file to open.\u000A *           seq       - RETURN: one sequence\u000A *           name      - RETURN: name of the sequence\u000A *           seqlen    - RETURN: length of the sequence in residues\u000A *           ffp       - ptr to a FASTAFILE object.\u000A *           \u000A * Commentary: \u000A *           The basic problem with reading FASTA files is that there is\u000A *           no end-of-record indicator. When you're reading sequence n, \u000A *           you don't know you're done until you've read the header line\u000A *           for sequence n+1, which you won't parse 'til later (when \u000A *           you're reading in the sequence n+1). One common trick for\u000A *           this is to implement a one-line \"lookahead\" buffer that you\u000A *           can peek at, before parsing later. \u000A *           \u000A *           This buffer is kept in a small structure (a FASTAFILE), rather\u000A *           than in a static char[] in the function. This allows\u000A *           us to have multiple FASTA files open at once. The static approach\u000A *           would only allow us to have one file open at a time. ANSI C\u000A *           predates the widespread use of parallel programming. It was\u000A *           not overly concerned about the drawbacks of statics. Today,\u000A *           though, you should keep in mind that you may someday want to\u000A *           turn your program into a multithreaded, parallel program, and\u000A *           all functions in parallelized code must be \"reentrant\": able to\u000A *           be called a second time - with different arguments,\u000A *           and while the code in the first function call is still executing! -\u000A *           without overwriting or corrupting any static storage in the\u000A *           function. Statics have fewer uses now (for example, to\u000A *           test that some initialization code for a function is run once \u000A *           and only once.)\u000A * \u000A * Limitations:          \u000A *           There is no error handling, for clarity's sake. Also,\u000A *           the parser is brittle. Improper FASTA files (for instance,\u000A *           blank lines between records) will cause unexpected\u000A *           behavior. Real file parsers are more complex.\u000A *           In real life, they have to deal with absolutely anything the user might\u000A *           pass as a \"FASTA file\"; and either parse it correctly,\u000A *           or detect that it's an invalid format and fail cleanly.\u000A *           \u000A *           Lines are read in from the file using ANSI C's fgets(). fgets()\u000A *           requires a maximum buffer length (here, FASTA_MAXLINE, which is\u000A *           defined as 512 in bio5495.h). Some FASTA files have very long\u000A *           description lines, however; notably the NCBI NR database. Static\u000A *           limitations on things like line or sequence lengths should be\u000A *           avoided. An example of a replacement for fgets() that dynamically\u000A *           allocates its buffer size and allows any line length is\u000A *           SQUID's sre_fgets().\u000A *           \u000A *           We use ANSI C's strtok() to parse the sequence name out of the line.\u000A *           strtok() is deprecated in modern programs because it is not threadsafe. \u000A *           (See comments above.) An example of a threadsafe version is\u000A *           SQUID's sre_strtok().\u000A *           \u000A * Returns:  \u000A *           OpenFASTA() returns a FASTAFILE pointer, or NULL on failure (for\u000A *           instance, if the file doesn't exist, or isn't readable).\u000A *           \u000A *           ReadFASTA() returns 1 on success, or a 0 if there are no\u000A *           more sequences to read in the file.\u000A *           \u000A *           CloseFASTA() \"always succeeds\" and returns void.\u000A */\u000AFASTAFILE *\u000AOpenFASTA(char *seqfile)\u000A{\u000A  FASTAFILE *ffp;\u000A\u000A  ffp = (FASTAFILE *) malloc(sizeof(FASTAFILE));\u000A  ffp->fp = fopen(seqfile, \"r\");              /* Assume seqfile exists & readable!   */\u000A  if (ffp->fp == NULL) { free(ffp); return NULL; } \u000A  if ((fgets(ffp->buffer, FASTA_MAXLINE, ffp->fp)) == NULL)\u000A    { free(ffp); return NULL; }\u000A  return ffp;\u000A}\u000A\u000Aint\u000AReadFASTA(FASTAFILE *ffp, char **ret_seq, char **ret_name, int *ret_L)\u000A{\u000A  char *s;\u000A  char *name;\u000A  char *seq;\u000A  int   n;\u000A  int   nalloc;\u000A  \u000A  /* Peek at the lookahead buffer; see if it appears to be a valid FASTA descline.\u000A   */\u000A  if (ffp->buffer[0] != '>') return 0;    \u000A\u000A  /* Parse out the name: the first non-newline token after the >\u000A   */\u000A  s  = strtok(ffp->buffer+1, \"\\n\");\u000A  name = (char *) malloc(sizeof(char) * (strlen(s)+1));\u000A  strcpy(name, s);\u000A\u000A  /* Everything else 'til the next descline is the sequence.\u000A   * Note the idiom for dynamic reallocation of seq as we\u000A   * read more characters, so we don't have to assume a maximum\u000A   * sequence length.\u000A   */\u000A  seq = (char *) malloc(sizeof(char) * 128);     /* allocate seq in blocks of 128 residues */\u000A  nalloc = 128;\u000A  n = 0;\u000A  while (fgets(ffp->buffer, FASTA_MAXLINE, ffp->fp))\u000A    {\u000A      if (ffp->buffer[0] == '>') break;\t/* a-ha, we've reached the next descline */\u000A\u000A      for (s = ffp->buffer; *s != '\\0'; s++)\u000A\t{\u000A\t  if (! isalpha(*s)) continue;  /* accept any alphabetic character */\u000A\u000A\t  seq[n] = *s;                  /* store the character, bump length n */\u000A\t  n++;\u000A\t  if (nalloc == n)\t        /* are we out of room in seq? if so, expand */\u000A\t    {\t\t\t        /* (remember, need space for the final '\\0')*/\u000A\t      nalloc += 128;\u000A\t      seq = (char *) realloc(seq, sizeof(char) * nalloc);\u000A\t    }\u000A\t}\u000A    }\u000A  seq[n] = '\\0';\u000A\u000A  *ret_name = name;\u000A  *ret_seq  = seq;\u000A  *ret_L    = n;\u000A  return 1;\u000A}      \u000A\u000Avoid\u000ACloseFASTA(FASTAFILE *ffp)\u000A{\u000A  fclose(ffp->fp);\u000A  free(ffp);\u000A}"}, {"path":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/fasta.h", "name":"fasta.h", "has_active_debug_locs":false, "absName":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/fasta.h", "content":"/* fasta.h\u000A * Declarations for simple FASTA i/o library\u000A * SRE, Sun Sep  8 05:37:38 2002 [AA2721, transatlantic]\u000A * CVS $Id$\u000A */\u000A\u000A#include <stdio.h>\u000A\u000A#define FASTA_MAXLINE 512\t/* Requires FASTA file lines to be <512 characters */\u000A\u000Atypedef struct fastafile_s {\u000A  FILE *fp;\u000A  char  buffer[FASTA_MAXLINE];\u000A} FASTAFILE;\u000A\u000Aextern FASTAFILE *OpenFASTA(char *seqfile);\u000Aextern int        ReadFASTA(FASTAFILE *fp, char **ret_seq, char **ret_name, int *ret_L);\u000Aextern void       CloseFASTA(FASTAFILE *ffp);"}, {"path":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/metaprogramming_utils.hpp", "name":"metaprogramming_utils.hpp", "has_active_debug_locs":false, "absName":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/metaprogramming_utils.hpp", "content":"#ifndef __METAPROGRAMMING_UTILS_HPP__\u000A#define __METAPROGRAMMING_UTILS_HPP__\u000A\u000A#include <type_traits>\u000A\u000Anamespace fpga_tools {\u000A\u000A//\u000A// The code below creates the constexprs 'make_integer_range'\u000A// and 'make_index_range' these are akin to 'std::make_integer_sequence'\u000A// and 'std::make_index_sequence', respectively.\u000A// However they allow you to specificy a range and can either increment\u000A// or decrement, rather than a strict increasing sequence\u000A//\u000Atemplate <typename T, typename, T begin, bool increase>\u000Astruct integer_range_impl;\u000A\u000A// incrementing case\u000Atemplate <typename T, T... N, T begin>\u000Astruct integer_range_impl<T, std::integer_sequence<T, N...>, begin, true> {\u000A  using type = std::integer_sequence<T, N + begin...>;\u000A};\u000A\u000A// decrementing case\u000Atemplate <typename T, T... N, T begin>\u000Astruct integer_range_impl<T, std::integer_sequence<T, N...>, begin, false> {\u000A  using type = std::integer_sequence<T, begin - N...>;\u000A};\u000A\u000A// integer_range\u000Atemplate <typename T, T begin, T end>\u000Ausing integer_range = typename integer_range_impl<\u000A    T, std::make_integer_sequence<T, (begin < end) ? end - begin : begin - end>,\u000A    begin, (begin < end)>::type;\u000A\u000A//\u000A// make_integer_range\u000A//\u000A// USAGE:\u000A//    make_integer_range<int,1,10>{} ==> 1,2,...,9\u000A//    make_integer_range<int,10,1>{} ==> 10,9,...,2\u000A//\u000Atemplate <class T, T begin, T end>\u000Ausing make_integer_range = integer_range<T, begin, end>;\u000A\u000A//\u000A// make_index_range\u000A//\u000A// USAGE:\u000A//    make_index_range<1,10>{} ==> 1,2,...,9\u000A//    make_index_range<10,1>{} ==> 10,9,...,2\u000A//\u000Atemplate <std::size_t begin, std::size_t end>\u000Ausing make_index_range = integer_range<std::size_t, begin, end>;\u000A\u000A//\u000A// The code below creates the constexprs 'make_integer_pow2_sequence'\u000A// and 'make_index_pow2_sequence'. These generate the sequence\u000A// 2^0, 2^1, 2^2, ... , 2^(N-1) = 1,2,4,...,2^(N-1)\u000A//\u000Atemplate <typename T, typename>\u000Astruct integer_pow2_sequence_impl;\u000A\u000Atemplate <typename T, T... Pows>\u000Astruct integer_pow2_sequence_impl<T, std::integer_sequence<T, Pows...>> {\u000A  using type = std::integer_sequence<T, (T(1) << Pows)...>;\u000A};\u000A\u000A// integer_pow2_sequence\u000Atemplate <typename T, T N>\u000Ausing integer_pow2_sequence =\u000A    typename integer_pow2_sequence_impl<T,\u000A                                        std::make_integer_sequence<T, N>>::type;\u000A\u000A//\u000A// make_integer_pow2_sequence\u000A//\u000A// USAGE:\u000A//    make_integer_pow2_sequence<int,5>{} ==> 1,2,4,8,16\u000A//\u000Atemplate <class T, T N>\u000Ausing make_integer_pow2_sequence = integer_pow2_sequence<T, N>;\u000A\u000A//\u000A// make_index_pow2_sequence\u000A//\u000A// USAGE:\u000A//    make_index_pow2_sequence<5>{} ==> 1,2,4,8,16\u000A//\u000Atemplate <std::size_t N>\u000Ausing make_index_pow2_sequence = integer_pow2_sequence<std::size_t, N>;\u000A\u000A//\u000A// Checks for existence of subscript operator\u000A//\u000Anamespace detail {\u000Atemplate <typename... >\u000Ausing void_t = void;\u000A\u000Atemplate<class T, typename = void>\u000Astruct has_subscript_impl : std::false_type { };\u000A\u000Atemplate<typename T>\u000Astruct has_subscript_impl<T, void_t<decltype(std::declval<T>()[1])>> \u000A  : std::true_type { };\u000A}  // namespace detail\u000A\u000Atemplate <typename T>\u000Astruct has_subscript {\u000A  static constexpr bool value =\u000A    std::is_same_v<typename detail::has_subscript_impl<T>::type, std::true_type>;\u000A};\u000A\u000Atemplate <typename T>\u000Ainline constexpr bool has_subscript_v = has_subscript<T>::value;\u000A\u000A//\u000A// checks if a type is any instance of SYCL pipe\u000A//\u000Anamespace detail {\u000A\u000Atemplate<typename T>\u000Astruct is_sycl_pipe_impl : std::false_type {};\u000A\u000Atemplate<typename Id, typename T, std::size_t N>\u000Astruct is_sycl_pipe_impl<sycl::ext::intel::pipe<Id, T, N>> : std::true_type {};\u000A\u000A}  // namespace detail\u000A\u000Atemplate <typename T>\u000Astruct is_sycl_pipe {\u000A  static constexpr bool value = detail::is_sycl_pipe_impl<T>{};\u000A};\u000A\u000Atemplate <typename T>\u000Ainline constexpr bool is_sycl_pipe_v = is_sycl_pipe<T>::value;\u000A\u000A} // namespace fpga_tools\u000A\u000A#endif  /* __METAPROGRAMMING_UTILS_HPP__ */"}, {"path":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/pipe_utils.hpp", "name":"pipe_utils.hpp", "has_active_debug_locs":false, "absName":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/pipe_utils.hpp", "content":"//==============================================================\u000A// Copyright Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A#ifndef __PIPE_UTILS_HPP__\u000A#define __PIPE_UTILS_HPP__\u000A\u000A#include <sycl/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#include <utility>\u000A\u000A/*\u000A\u000AThis header defines the following utilities for use with pipes in SYCL FPGA\u000Adesigns.\u000A\u000A1. PipeArray\u000A\u000A      Create a collection of pipes that can be indexed like an array.\u000A\u000A      template <class Id,          // identifier for the pipe array\u000A                typename BaseTy,   // type to write/read for each pipe\u000A                size_t min_depth,  // minimum capacity of each pipe\u000A                size_t... dims     // depth of each dimension in the array\u000A                                   // any number of dimensions are supported\u000A                >\u000A      struct PipeArray\u000A\u000A      Example usage:\u000A    \u000A      class PipeArrayId;\u000A      constexpr int min_depth = 0;\u000A      constexpr int num_pipes = 4;\u000A      using MyPipeArray = PipeArray<PipeArrayId, int, min_depth, num_pipes>;\u000A      ...\u000A      constexpr int pipe_idx = 1;\u000A      MyPipeArray::PipeAt<pipe_idx>::read(); \u000A\u000A2. PipeDuplicator\u000A\u000A      Fan-out a single pipe write to multiple pipe instances,\u000A      each of which will receive the same data.\u000A      A blocking write will perform a blocking write to each pipe.\u000A      A non-blocking write will perform a non-blocking write to each pipe,\u000A      and set success to true only if ALL writes were successful.\u000A\u000A      Note that the special case of 0 pipe instances is supported, which can \u000A      be useful as a stub for writes to pipes that are not needed in your particular \u000A      design.\u000A\u000A      template <class Id,          // name of this PipeDuplicator\u000A                typename T,        // data type to transfer\u000A                typename... Pipes  // all pipes to send duplicated writes to\u000A                >\u000A      struct PipeDuplicator\u000A\u000A      Example usage:\u000A\u000A      class PipeID1;\u000A      class PipeID2;\u000A      using MyPipe1 = sycl::ext::intel::pipe<PipeID1, int>;\u000A      using MyPipe2 = sycl::ext::intel::pipe<PipeID2, int>;\u000A\u000A      class PipeDuplicatorID;\u000A      using MyPipeDuplicator = PipeDuplicator<PipeDuplicatorID, int, MyPipe1, MyPipe2>;\u000A      ...\u000A      MyPipeDuplicator::write(1); // write the value 1 to both MyPipe1 and MyPipe2\u000A\u000A*/\u000A\u000A// =============================================================\u000A// Internal Helper Functions/Structs\u000A// =============================================================\u000A\u000Anamespace fpga_tools {\u000Anamespace detail {\u000A\u000A// Templated classes for verifying dimensions when accessing elements in the\u000A// pipe array.\u000Atemplate <size_t dim1, size_t... dims>\u000Astruct VerifierDimLayer {\u000A  template <size_t idx1, size_t... idxs>\u000A  struct VerifierIdxLayer {\u000A    static constexpr bool IsValid() {\u000A      return idx1 < dim1 &&\u000A             (VerifierDimLayer<dims...>::template VerifierIdxLayer<\u000A                 idxs...>::IsValid());\u000A    }\u000A  };\u000A};\u000Atemplate <size_t dim>\u000Astruct VerifierDimLayer<dim> {\u000A  template <size_t idx>\u000A  struct VerifierIdxLayer {\u000A    static constexpr bool IsValid() { return idx < dim; }\u000A  };\u000A};\u000A\u000A// Templated classes to perform 'currying' write to all pipes in the array\u000A// Primary template, dummy\u000Atemplate <template <std::size_t...> class WriteFunc, typename BaseTy,\u000A          typename PartialSequence, typename... RemainingSequences>\u000Astruct write_currying {};\u000A// Induction case\u000Atemplate <template <std::size_t...> class WriteFunc, typename BaseTy,\u000A          std::size_t... I, std::size_t... J, typename... RemainingSequences>\u000Astruct write_currying<WriteFunc, BaseTy, std::index_sequence<I...>,\u000A                      std::index_sequence<J...>, RemainingSequences...> {\u000A  void operator()(const BaseTy &data, bool &success) const {\u000A    (write_currying<WriteFunc, BaseTy, std::index_sequence<I..., J>,\u000A                    RemainingSequences...>()(data, success),\u000A     ...);\u000A  }\u000A};\u000A// Base case\u000Atemplate <template <std::size_t...> class WriteFunc, typename BaseTy,\u000A          std::size_t... I>\u000Astruct write_currying<WriteFunc, BaseTy, std::index_sequence<I...>> {\u000A  void operator()(const BaseTy &data, bool &success) const {\u000A    WriteFunc<I...>()(data, success);\u000A  }\u000A};\u000A\u000A}  // namespace detail\u000A\u000A// =============================================================\u000A// PipeArray\u000A// =============================================================\u000A\u000Atemplate <class Id,          // identifier for the pipe array\u000A          typename BaseTy,   // type to write/read for each pipe\u000A          size_t min_depth,  // minimum capacity of each pipe\u000A          size_t... dims     // depth of each dimension in the array\u000A                             // any number of dimensions are supported\u000A          >\u000Astruct PipeArray {\u000A  PipeArray() = delete;  // ensure we cannot create an instance\u000A\u000A  template <size_t... idxs>\u000A  struct StructId;  // the ID of each pipe in the array\u000A\u000A  // VerifyIndices checks that we only access pipe indicies that are in range\u000A  template <size_t... idxs>\u000A  struct VerifyIndices {\u000A    static_assert(sizeof...(idxs) == sizeof...(dims),\u000A                  \"Indexing into a PipeArray requires as many indices as \"\u000A                  \"dimensions of the PipeArray.\");\u000A    static_assert(fpga_tools::detail::VerifierDimLayer<dims...>::template\u000A                  VerifierIdxLayer<idxs...>::IsValid(),\u000A                  \"Index out of bounds\");\u000A    using VerifiedPipe =\u000A        sycl::ext::intel::pipe<StructId<idxs...>, BaseTy, min_depth>;\u000A  };\u000A\u000A  // helpers for accessing the dimensions of the pipe array\u000A  // usage:\u000A  //  MyPipeArray::GetNumDims() - number of dimensions in this pipe array\u000A  //  MyPipeArray::GetDimSize<3>() - size of dimension 3 in this pipe array\u000A  static constexpr size_t GetNumDims() { return (sizeof...(dims)); }\u000A  template <int dim_num>\u000A  static constexpr size_t GetDimSize() {\u000A    return std::get<dim_num>(dims...);\u000A  }\u000A\u000A  // PipeAt<idxs...> is used to reference a pipe at a particular index\u000A  template <size_t... idxs>\u000A  using PipeAt = typename VerifyIndices<idxs...>::VerifiedPipe;\u000A\u000A  // functor to impllement blocking write to all pipes in the array\u000A  template <std::size_t... I>\u000A  struct BlockingWriteFunc {\u000A    void operator()(const BaseTy &data, bool &success) const {\u000A      PipeAt<I...>::write(data);\u000A    }\u000A  };\u000A  // functor to impllement non-blocking write to all pipes in the array\u000A  template <std::size_t... I>\u000A  struct NonBlockingWriteFunc {\u000A    void operator()(const BaseTy &data, bool &success) const {\u000A      PipeAt<I...>::write(data, success);\u000A    }\u000A  };\u000A  // helper function for implementing write() call to all pipes in the array\u000A  template <template <std::size_t...> class WriteFunc,\u000A            typename... IndexSequences>\u000A  static void write_currying_helper(const BaseTy &data, bool &success,\u000A                                    IndexSequences...) {\u000A    fpga_tools::detail::write_currying<WriteFunc, BaseTy,\u000A                   std::index_sequence<>, IndexSequences...>()(data, success);\u000A  }\u000A\u000A  // blocking write\u000A  // write the same data to all pipes in the array using blocking writes\u000A  static void write(const BaseTy &data) {\u000A    bool success;  // temporary variable, ignored in BlockingWriteFunc\u000A    write_currying_helper<BlockingWriteFunc>(\u000A        data, success, std::make_index_sequence<dims>()...);\u000A  }\u000A\u000A  // non-blocking write\u000A  // write the same data to all pipes in the array using non-blocking writes\u000A  static void write(const BaseTy &data, bool &success) {\u000A    write_currying_helper<NonBlockingWriteFunc>(\u000A        data, success, std::make_index_sequence<dims>()...);\u000A  }\u000A\u000A};  // end of struct PipeArray\u000A\u000A// =============================================================\u000A// PipeDuplicator\u000A// =============================================================\u000A\u000A// Connect a kernel that writes to a single pipe to multiple pipe instances,\u000A// each of which will receive the same data.\u000A// A blocking write will perform a blocking write to each pipe.  A non-blocking\u000A// write will perform a non-blocking write to each pipe, and set success to\u000A// true only if ALL writes were successful.\u000A\u000A// primary template, dummy\u000Atemplate <class Id,          // name of this PipeDuplicator\u000A          typename T,        // data type to transfer\u000A          typename... Pipes  // all pipes to send duplicated writes to\u000A          >\u000Astruct PipeDuplicator {};\u000A\u000A// recursive case, write to each pipe\u000Atemplate <class Id,                   // name of this PipeDuplicator\u000A          typename T,                 // data type to transfer\u000A          typename FirstPipe,         // at least one output pipe\u000A          typename... RemainingPipes  // additional copies of the output pipe\u000A          >\u000Astruct PipeDuplicator<Id, T, FirstPipe, RemainingPipes...> {\u000A  PipeDuplicator() = delete;  // ensure we cannot create an instance\u000A\u000A  // Non-blocking write\u000A  static void write(const T &data, bool &success) {\u000A    bool local_success;\u000A    FirstPipe::write(data, local_success);\u000A    success = local_success;\u000A    PipeDuplicator<Id, T, RemainingPipes...>::write(data, local_success);\u000A    success &= local_success;\u000A  }\u000A\u000A  // Blocking write\u000A  static void write(const T &data) {\u000A    FirstPipe::write(data);\u000A    PipeDuplicator<Id, T, RemainingPipes...>::write(data);\u000A  }\u000A};\u000A\u000A// base case for recursion, no pipes to write to\u000A// also useful as a 'null' pipe, writes don't do anything\u000Atemplate <class Id,   // name of this PipeDuplicator\u000A          typename T  // data type to transfer\u000A          >\u000Astruct PipeDuplicator<Id, T> {\u000A  PipeDuplicator() = delete;  // ensure we cannot create an instance\u000A\u000A  // Non-blocking write\u000A  static void write(const T & /*data*/, bool &success) { success = true; }\u000A\u000A  // Blocking write\u000A  static void write(const T & /*data*/) {\u000A    // do nothing\u000A  }\u000A};\u000A\u000A} // namespace fpga_tools\u000A\u000A#endif /* __PIPE_UTILS_HPP__ */"}, {"path":"/opt/intel/oneapi/tbb/2021.8.0/include/tbb/tbb.h", "name":"tbb.h", "has_active_debug_locs":false, "absName":"/opt/intel/oneapi/tbb/2021.8.0/include/tbb/tbb.h", "content":"/*\u000A    Copyright (c) 2005-2021 Intel Corporation\u000A\u000A    Licensed under the Apache License, Version 2.0 (the \"License\");\u000A    you may not use this file except in compliance with the License.\u000A    You may obtain a copy of the License at\u000A\u000A        http://www.apache.org/licenses/LICENSE-2.0\u000A\u000A    Unless required by applicable law or agreed to in writing, software\u000A    distributed under the License is distributed on an \"AS IS\" BASIS,\u000A    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\u000A    See the License for the specific language governing permissions and\u000A    limitations under the License.\u000A*/\u000A\u000A#include \"../oneapi/tbb.h\"\u000A"}, {"path":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/two_bit_v19_HBM_test_v12.cpp", "name":"two_bit_v19_HBM_test_v12.cpp", "has_active_debug_locs":false, "absName":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/two_bit_v19_HBM_test_v12.cpp", "content":"// Owen Lucas\u000A// Based on code from Kyle Buettner\u000A// Two bit counting bloom filter\u000A// Uses Algorithm from BFCounter and NEST\u000A// IMPORTANT: Consider atomic updates and race conditions when parallelizing\u000A\u000A\u000A//Now port this one to have 4 hash functions\u000A\u000A#include <omp.h>\t\t\t// Included for timing\u000A#include <string>\t\t\t\u000A#include <iostream>\u000A#include <bits/stdc++.h>\u000A#include <chrono>\u000A#include <algorithm>\u000A#include <cmath>\u000A#include <unordered_map>\u000A#include \"fasta.c\"\u000A\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#include <CL/sycl.hpp>\u000Ausing namespace cl::sycl;\u000A\u000A#include \"pipe_utils.hpp\"\u000A#include \"unrolled_loop.hpp\"\u000A\u000A#include \"dpc_common.hpp\"\u000A\u000A#define MAX_SEQ_L 512\u000A\u000A// Key parameters for Bloom filter -> These determine false positive probability (along with N)\u000A// M is now the number of indecies in each partition of the filter\u000A#define M 0x80000000\u000A#define K 31\u000A#define MAX_K_BYTES 8\u000A\u000A#define H 4\u000A#define BANKS 32\u000A#define BF_BANKS 31\u000A\u000A#define BIG_CONSTANT(x) (x##LLU)\u000A\u000A\u000Aclass produce_reads1;\u000Aclass parse_reads1;\u000Aclass add_to_bf;\u000A\u000Aclass produce_reads2;\u000Aclass parse_reads2;\u000Aclass query_bf;\u000A\u000Aclass compile_query;\u000A        \u000A\u000Astruct sequence {\u000A    std::bitset<2*MAX_SEQ_L> seq = 0;\u000A    unsigned int             L = 0;\u000A    bool                     valid = false;\u000A};\u000A\u000Astruct query {\u000A    //std::bitset<MAX_SEQ_L - K + 1> found = 0;\u000A\tstd::bitset<2*MAX_SEQ_L> seq = 0;\u000A    int seen = 0;\u000A};\u000A\u000Astruct hash_q {\u000A    unsigned int results[H];\u000A    unsigned int j = 0;\u000A    unsigned int i = 0;\u000A};\u000A\u000Astruct kmer_data{\u000A    std::bitset<MAX_K_BYTES * 8> kmer;\u000A    unsigned int seq_num = 0; // What sequence does this data go with\u000A    unsigned short kmer_num = 0; // What kmer in the sequence does it go with\u000A\u000A};\u000A\u000Astruct hash_result{\u000A    unsigned long long int result = 0;\u000A    bool done = false;\u000A    unsigned int seq_num = 0; // What sequence does this data go with\u000A    unsigned short kmer_num = 0; // What kmer in the sequence does it go with\u000A    unsigned short hash_num = 0; // What hash function is it from\u000A};\u000A\u000Astruct bank_query{\u000A    bool found;\u000A    unsigned int seq_num = 0; // What sequence does this data go with\u000A    unsigned short kmer_num = 0; // What kmer in the sequence does it go with\u000A};\u000A\u000Astruct partial_query {\u000A    //std::bitset<MAX_SEQ_L - K + 1> found = 0;\u000A\tstd::bitset<2*MAX_SEQ_L> found = 0;\u000A    int seq_num = 0;\u000A};\u000A\u000Ausing seq_pipe = ext::intel::pipe<class some_pipe, sequence, 16>;\u000Ausing seq_pipe2 = ext::intel::pipe<class other_pipe, sequence, 16>;\u000Ausing res_pipe = ext::intel::pipe<class other_pipe2, unsigned long long int, 64>;\u000A//using res_pipe2 = ext::intel::pipe<class other_pipe3, hash_q, 16>;\u000A//using kmer2hash = ext::intel::pipe<class other_pipe4, kmer_data, 16>;\u000A//using hash2bank = ext::intel::pipe<class other_pipe5, hash_result, 16>;\u000A//using bank2comp = ext::intel::pipe<class other_pipe5, bank_query, 16>;\u000A\u000Ausing kmer2hash_pipes = fpga_tools::PipeArray<    // Defined in \"pipe_utils.hpp\".\u000A    class array_pipe1,               // An identifier for the pipe.\u000A    kmer_data,   // The type of data in the pipe.\u000A    16,                            // The capacity of each pipe.\u000A    H                             // array dimension.\u000A    >;\u000A\u000Ausing hash2bank_pipes = fpga_tools::PipeArray<    // Defined in \"pipe_utils.hpp\".\u000A    class array_pipe2,               // An identifier for the pipe.\u000A    hash_result,                    // The type of data in the pipe.\u000A    16,                            // The capacity of each pipe.\u000A    (BF_BANKS)                         // array dimension.\u000A    >;\u000A\t\u000Ausing bank2comp_pipes = fpga_tools::PipeArray<    // Defined in \"pipe_utils.hpp\".\u000A    class array_pipe3,               // An identifier for the pipe.\u000A    bank_query,                    // The type of data in the pipe.\u000A    16,                            // The capacity of each pipe.\u000A    (BF_BANKS)                         // array dimension.\u000A    >;\u000A\t\u000Ausing len2comp_pipes = fpga_tools::PipeArray<    // Defined in \"pipe_utils.hpp\".\u000A    class array_pipe4,               // An identifier for the pipe.\u000A    int,   // The type of data in the pipe.\u000A    64,                            // The capacity of each pipe.\u000A    H                             // array dimension.\u000A    >;\u000A\t\u000Ausing comp2final_pipes = fpga_tools::PipeArray<    // Defined in \"pipe_utils.hpp\".\u000A    class array_pipe5,               // An identifier for the pipe.\u000A    partial_query,   // The type of data in the pipe.\u000A    16,                            // The capacity of each pipe.\u000A    H                             // array dimension.\u000A    >;\u000A\u000A\u000A\u000A\u000Aunsigned int MurmurHash2 ( const void * key, unsigned int seed )\u000A{\u000A\t// 'm' and 'r' are mixing constants generated offline.\u000A\t// They're not really 'magic', they just happen to work well.\u000A\u000A\tconst unsigned int m = 0x5bd1e995;\u000A\tconst int r = 24;\u000A    const int length =  MAX_K_BYTES; \u000A\t// Initialize the hash to a 'random' value\u000A\u000A\tunsigned int h = seed ^ length;\u000A\u000A\t// Mix 4 bytes at a time into the hash\u000A\u000A\tconst unsigned char * data = (const unsigned char *)key;\u000A\u000A\t//while(len >= 4)\u000A    for (int x = 4; x <= length; x = x + 4)\u000A\t{\u000A\t\tunsigned int k = *(unsigned int *)data;\u000A\u000A\t\tk *= m; \u000A\t\tk ^= k >> r; \u000A\t\tk *= m; \u000A\t\t\u000A\t\th *= m; \u000A\t\th ^= k;\u000A\u000A\t\tdata += 4;\u000A\t\t//len -= 4;\u000A\t}\u000A\t\u000A\t// Handle the last few bytes of the input array\u000A    \u000A    int rem = length & 3;\u000A    \u000A    if (rem != 0){\u000A\u000A        switch(rem)\u000A        {\u000A        case 3: h ^= data[2] << 16;\u000A        case 2: h ^= data[1] << 8;\u000A        case 1: h ^= data[0];\u000A                h *= m;\u000A        };\u000A    }\u000A\u000A\t// Do a few final mixes of the hash to ensure the last few\u000A\t// bytes are well-incorporated.\u000A\u000A\th ^= h >> 13;\u000A\th *= m;\u000A\th ^= h >> 15;\u000A\u000A\treturn h;\u000A}\u000A\u000Aunsigned long long int MurmurHash64A ( const void * key, uint64_t seed )\u000A{\u000A  const long long unsigned int m = BIG_CONSTANT(0xc6a4a7935bd1e995);\u000A  const int r = 47;\u000A  const int length =  MAX_K_BYTES; \u000A\u000A  unsigned long long int h = seed ^ (length * m);\u000A\u000A  const unsigned long long int * data = (const long long unsigned int *)key;\u000A  const unsigned long long int * end = data + (length/8);\u000A\u000A   for (int x = 8; x <= length; x = x + 8)\u000A  {\u000A    long long unsigned int k = *data++;\u000A\u000A    k *= m; \u000A    k ^= k >> r; \u000A    k *= m; \u000A    \u000A    h ^= k;\u000A    h *= m; \u000A  }\u000A\u000A  const unsigned char * data2 = (const unsigned char*)data;\u000A    \u000A  int rem = length & 7;\u000A  if(rem != 0){\u000A\u000A      switch(rem)\u000A      {\u000A          case 7: h ^= ((long long unsigned int) data2[6]) << 48;\u000A          case 6: h ^= ((long long unsigned int) data2[5]) << 40;\u000A          case 5: h ^= ((long long unsigned int) data2[4]) << 32;\u000A          case 4: h ^= ((long long unsigned int) data2[3]) << 24;\u000A          case 3: h ^= ((long long unsigned int) data2[2]) << 16;\u000A          case 2: h ^= ((long long unsigned int) data2[1]) << 8;\u000A          case 1: h ^= ((long long unsigned int) data2[0]);\u000A                  h *= m;\u000A      };\u000A  }\u000A \u000A  h ^= h >> r;\u000A  h *= m;\u000A  h ^= h >> r;\u000A\u000A  return h;\u000A} \u000A\u000A// Bloom Filter Code\u000Avoid add_to_bloom_filter(unsigned long long int kmer, volatile char *bloom_filter){\u000A\t#pragma unroll\u000A    for(int i = 0; i < H; i++){\u000A        unsigned int result = MurmurHash2(&kmer, i) & (M-1);\u000A        short lower = (result & 3) << 1;\u000A        unsigned int upper = result >> 2;\u000A        char bf_byte = bloom_filter[upper];\u000A        unsigned int idx = 1 << lower;\u000A        if(bf_byte && idx != 0){\u000A            bf_byte = bf_byte | (idx << 1);\u000A        }\u000A\t\tbf_byte = bf_byte |  idx;\u000A        bloom_filter[upper] = bloom_filter[upper] | bf_byte;\u000A\t}\u000A}\u000A\u000A// Bloom Filter Code\u000Aint query_bloom_filter(unsigned long long int kmer, volatile char *bloom_filter){ \u000A\tstd::bitset<H> found;\u000A    found.reset();\u000A    #pragma unroll\u000A\tfor(int i = 0; i < H; i++){\u000A        unsigned int result = MurmurHash2(&kmer, i) & (M-1);\u000A        short lower = (result & 3) << 1;\u000A        unsigned int upper = result >> 2;\u000A        unsigned int idx = 1 << lower;\u000A\t\tfound[i] = ((bloom_filter[upper] & (idx << 1)) != 0);\u000A\t}\u000A\treturn (int)found.all();\u000A}\u000A\u000Achar convert_int_to_base(unsigned int base) {\u000A\tif (base == 0) {\u000A\t\treturn 'A';\u000A\t}\u000A\telse if (base == 1) {\u000A\t\treturn 'C';\u000A\t}\u000A\telse if (base == 2) {\u000A\t\treturn 'G';\u000A\t}\u000A\telse if (base == 3) {\u000A\t\treturn 'T';\u000A\t}\u000A\treturn 'N';\u000A}\u000A\u000Avoid convert_int_to_word(unsigned long long int word, char *temp_word) {\u000A\tunsigned long long int shift_mask = 3; // Bits = 11\u000A\tfor (int i = 0; i < K; i++) {\u000A\t\tchar c = convert_int_to_base((word & (shift_mask << (2 * (K-i-1)))) >> (2 * (K-i-1)));\u000A\t\ttemp_word[i] = c;\u000A\t}\u000A\ttemp_word[K] = '\\0';\u000A}\u000A\u000A\u000A\u000Aunsigned long long int convert_base_to_int(char base){\u000A\tif(base == 'A'){\u000A\t\treturn 0;\u000A\t}\u000A\telse if(base == 'C'){\u000A\t\treturn 1;\u000A\t}\u000A\telse if(base == 'G'){\u000A\t\treturn 2;\u000A\t}\u000A\telse if(base == 'T'){\u000A\t\treturn 3;\u000A\t}\u000A\telse {//error\u000A\t\treturn 0;\u000A\t}\u000A}\u000A\u000Aunsigned long long int convert_word_to_int(char word[K+1]){\u000A\tunsigned long long int word_as_int = 0;\u000A\tfor (int i = 0; i < K; i++){\u000A\t\tword_as_int |= (convert_base_to_int(word[i]) << (2*i));\u000A\t}\u000A\treturn word_as_int;\u000A}\u000A\u000A\u000Avoid print_hash_lookup_table(std::unordered_map<unsigned long long int, int>* hash_lookup_table){\u000A\tstd::unordered_map<unsigned long long int, int>::iterator itr; \u000A\tchar kmer[K+1];\u000A\tkmer[K] = '\\0';\u000A\tint total = 0;\u000A\tfor(itr = hash_lookup_table->begin(); itr !=  hash_lookup_table->end(); itr++){\u000A\t\tconvert_int_to_word(itr->first, kmer);\u000A\t\tprintf(\"\\n%s: \", kmer);\u000A\t\tprintf(\"%d\", itr->second);\u000A\t\ttotal += itr->second;\u000A\t\t\u000A\t}\u000A\tprintf(\"\\nTotal # of k-mers in the hash table: %d\\n\", total);\u000A}\u000A\u000A \u000A\u000Aint main (int argc, char *argv[]) {\u000A    \u000A    \u000A    // Select either:\u000A    //  - the FPGA emulator device (CPU emulation of the FPGA)\u000A    //  - the FPGA device (a real FPGA)\u000A    #if defined(FPGA_EMULATOR)\u000A        ext::intel::fpga_emulator_selector device_selector;\u000A    #else\u000A        ext::intel::fpga_selector device_selector;\u000A    #endif\u000A    \u000A    try{\u000A\u000A        // Need to load files(s)\u000A        // Maybe add command line argument to determine if short read or database\u000A        // Command line argument for name of file\u000A\u000A        //FILE *query_file;\u000A        FILE *database_file;\u000A\t\u000A        FASTAFILE *ffp;\u000A        \u000A        char *seq;\u000A        char *name;\u000A        int L;\u000A\u000A        char* file_name = \"./data/sra_data.fasta\";\u000A\u000A        ffp = OpenFASTA(file_name);\u000A        long long unsigned int num_database_char = 0;\u000A\u000A        char c;\u000A\u000A        char kmer[K+1];\u000A        kmer[K] = '\\0';\u000A        long long unsigned int reverse_mask = pow(2, (2 * K));\u000A        reverse_mask = reverse_mask - 1;\u000A        long long unsigned int one = 1;\u000A        long long unsigned int check_mask = pow(2, (2 * K -1)); //check if the top bit is 1\u000A        \u000A    \u000A        int total_valid_reads = 0;\u000A        unsigned long long int total_nucleotides = 0;\u000A        unsigned long long int total_kmers = 0;\u000A\u000A        const int max_reads = 100000;\u000A\t\t\u000A\t\tconst int shift  = log2(M) - log2(BANKS/H);\u000A\u000A        \u000A        sequence* all_reads = (sequence*)malloc(sizeof(sequence) * max_reads);\u000A\t\t\u000A\t\tsequence* all_reads_dev = (sequence*)malloc(sizeof(sequence) * max_reads);\u000A        \u000A        //query* all_qs = (query*)malloc(sizeof(query) * max_reads);\u000A        \u000A        short* kmer_len = (short*)malloc(sizeof(short) * max_reads);\u000A        \u000A        \u000A        //read the sequecing reads from the file\u000A         while (ReadFASTA(ffp, &seq, &name, &L) && total_valid_reads < max_reads) {\u000A\u000A            if (L >= K){\u000A                \u000A                if(L > MAX_SEQ_L){\u000A                    L = MAX_SEQ_L;\u000A                }\u000A                \u000A                \u000A                std::bitset<2*MAX_SEQ_L> seq_bitset = 0;\u000A                std::bitset<2*MAX_SEQ_L> char_as_bits = 0;\u000A\u000A                for (int i = 0; i < L; i++){\u000A                    char_as_bits = 0; //any unknown char gets input as an A, should figure out what to actually do\u000A                    if (seq[i] == 'a' || seq[i] == 'A'){\u000A                        char_as_bits = 0;\u000A                    }\u000A                    else if(seq[i] == 'c' || seq[i] == 'C'){\u000A                        char_as_bits = 1;\u000A                    }\u000A                    else if(seq[i] == 'g' || seq[i] == 'G'){\u000A                        char_as_bits = 2;\u000A                    }\u000A                    else if(seq[i] == 't' || seq[i] == 'T'){\u000A                        char_as_bits = 3;\u000A                    }\u000A                    seq_bitset <<= 2;\u000A                    seq_bitset |= char_as_bits;\u000A                }\u000A                \u000A                all_reads[total_valid_reads].seq = seq_bitset;\u000A                all_reads[total_valid_reads].L = L;\u000A                all_reads[total_valid_reads].valid = true;\u000A                \u000A\t\t\t\tall_reads_dev[total_valid_reads].seq = seq_bitset;\u000A                all_reads_dev[total_valid_reads].L = L;\u000A                all_reads_dev[total_valid_reads].valid = true;\u000A\t\t\t\t\u000A                kmer_len[total_valid_reads] = (L- K + 1);\u000A                \u000A                total_valid_reads++;\u000A                total_nucleotides += L;\u000A                total_kmers += (L- K + 1);\u000A            }\u000A            free(seq);\u000A            free(name);\u000A        }\u000A        \u000A        CloseFASTA(ffp);\u000A\u000A        \u000A        // Create a queue bound to the chosen device.\u000A        // If the device is unavailable, a SYCL runtime exception is thrown.\u000A        printf(\"Going to attempt to create the queue\\n\");\u000A        sycl::queue q(device_selector, dpc_common::exception_handler);\u000A        printf(\"Queue has been made\\n\");\u000A\u000A        // Print out the device information.\u000A        std::cout << \"Running on device: \"\u000A                  << q.get_device().get_info<info::device::name>() << \"\\n\";\u000A        \u000A        auto start_sw = std::chrono::high_resolution_clock::now();\u000A    \u000A        //volatile char *bf = (char *)malloc_device(M/4, q);\u000A        \u000A        /*q.submit([&](handler& h) {\u000A             h.memset((void *)bf, 0, M/4);\u000A\u000A         });*/\u000A        \u000A        //buffer<char, 1> bf_buf{M/4}; \u000A\u000A        bool compose_finished = false;\u000A\t\t\u000A\t\tsycl::range<1> bytes_per_bank{(size_t)((M/(BANKS/H))/4)};\u000A\t\t\u000A\t\tstd::vector<sycl::buffer<char,1>*> bank_bufs;\u000A\t\t\u000A\t\tfor(int i = 0; i < BANKS - 1; i++){ \u000A            sycl::buffer<char,1> *bank_buffer = new sycl::buffer<char,1>(bytes_per_bank);\u000A            bank_bufs.push_back(bank_buffer);\u000A        }\u000A        \u000A        \u000A\u000A\t\t{buffer<sequence, 1> seq_buf{(all_reads_dev), range{(unsigned long long)total_valid_reads}};\u000A\u000A        auto e = q.submit([&](handler &h) {\u000A            accessor input_accessor(seq_buf, h, read_write, ext::oneapi::accessor_property_list{sycl::ext::oneapi::no_alias, ext::intel::buffer_location<0>});\u000A            //size_t num_elements = input_buffer.get_count();\u000A\u000A            h.single_task<produce_reads1>([=]() {\u000A\t\t\t\tfor (int loop = 0; loop < 2; loop++){ //one loop for composition, next for query\u000A\t\t\t\t\tfor (int j = 0; j < total_valid_reads; j++){\u000A\t\t\t\t\t\t//bool success = false;\u000A\t\t\t\t\t\t//do{\u000A\t\t\t\t\t\t\t//if(input_accessor[j].valid){\u000A\t\t\t\t\t\tsequence curr_seq = input_accessor[j];\u000A\t\t\t\t\t\tseq_pipe::write(curr_seq);\u000A\t\t\t\t\t\tif (loop == 1){ //now done with the reads, prepare to record the query data\u000A\t\t\t\t\t\t\tcurr_seq.seq.set();\u000A\t\t\t\t\t\t\tcurr_seq.L = 0;\u000A\t\t\t\t\t\t\tinput_accessor[j] = curr_seq;\u000A\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t//}\u000A\t\t\t\t\t\t//}while(!success);\u000A\t\t\t\t\t}\u000A\t\t\t\t}\u000A            });\u000A          });\u000A\u000A                \u000A        //split reads into cannonical k-mers and send to hash\u000A        auto e2 = q.submit([&](handler& h) {\u000A            h.single_task<parse_reads1>([=]()[[intel::kernel_args_restrict]]{\u000A\t\t\t\tfor (int loop = 0; loop < 2; loop++){ //one loop for composition, next for query\u000A\t\t\t\t\tfor (int j = 0; j < total_valid_reads; j++){\u000A\u000A\t\t\t\t\t\tsequence dev_seq = seq_pipe::read();\u000A\t\t\t\t\t\t\u000A\t\t\t\t\t\tif(loop == 1){\u000A                            fpga_tools::UnrolledLoop<H>([&](auto i) {\u000A                                len2comp_pipes::PipeAt<i>::write(dev_seq.L);\u000A                            });\u000A                        }\u000A\u000A\t\t\t\t\t\tfor(int i = 0; i < dev_seq.L - K + 1; i++){\u000A\t\t\t\t\t\t\tstd::bitset<2*K> kmer_bits = 0;\u000A\t\t\t\t\t\t\t#pragma unroll\u000A\t\t\t\t\t\t\tfor(int n = 0; n < K; n++){\u000A\t\t\t\t\t\t\t\tkmer_bits[n << 1] = dev_seq.seq[(i + n) << 1];\u000A\t\t\t\t\t\t\t\tkmer_bits[(n << 1) + 1] = dev_seq.seq[((i + n) << 1)+1];\u000A\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\tif (kmer_bits[(K << 1) -1]){\u000A\t\t\t\t\t\t\t\tkmer_bits.flip();\u000A\t\t\t\t\t\t\t}\u000A\u000A\t\t\t\t\t\t\tstd::bitset<MAX_K_BYTES * 8> kmer_bytes = 0;\u000A\t\t\t\t\t\t\t #pragma unroll\u000A\t\t\t\t\t\t\tfor (int s = 0; s < 2*K; s++){\u000A\t\t\t\t\t\t\t\tkmer_bytes[s] = kmer_bits[s];\u000A\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t\tkmer_data current_kmer;\u000A                            current_kmer.kmer = kmer_bytes;\u000A                            current_kmer.seq_num = j;\u000A                            current_kmer.kmer_num = i;\u000A\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t\tfpga_tools::UnrolledLoop<H>([&](auto hash_num) {\u000A\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t\t\tkmer2hash_pipes::PipeAt<hash_num>::write(current_kmer);\u000A\t\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t\t});\u000A\t\t\t\t\t\t\t\u000A\u000A\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t}\u000A\t\t\t\t\t}\u000A\t\t\t\t}\u000A            });\u000A        });\u000A        \u000A\t\t\u000A\t\t//split the hashing off into it's own kernel\u000A\t\tfpga_tools::UnrolledLoop<3>([&](auto i) {\u000A\t\t\tq.submit([&](handler& h) {\u000A\t\t\t\th.single_task([=]()[[intel::kernel_args_restrict]]{\u000A\t\t\t\t\t//out << \"This is hashing kernel\" << sycl::endl;\u000A\t\t\t\t\tlong long unsigned int top_bits = (M >> 1) + (M >> 2) + (M >> 3);\u000A\t\t\t\t\tfor (int loop = 0; loop < 2; loop++){\u000A\t\t\t\t\t\tfor (int j = 0; j < total_kmers; j++){\u000A\t\t\t\t\t\t\tkmer_data current_kmer = kmer2hash_pipes::PipeAt<i>::read();\u000A\t\t\t\t\t\t\t//for (int i =0; i < H; i++){\u000A\t\t\t\t\t\t\t//unsigned int result = MurmurHash2(&current_kmer.kmer, i) & (unsigned long long int)(M-1);\u000A\t\t\t\t\t\t\tunsigned long long int result = MurmurHash64A(&current_kmer.kmer, i) ;\u000A\t\t\t\t\t\t\t\u000A                            result &= (unsigned long long int)(M-1);\u000A\t\t\t\t\t\t\tshort bank_num = (result & top_bits) >> shift;\u000A                            hash_result  tiny_result;\u000A\t\t\t\t\t\t\ttiny_result.result = (result & ((M-1) >> 3)); //this gets sent to the bank, strip top 2 bits\u000A\t\t\t\t\t\t\t//tiny_result.result = result;\u000A\t\t\t\t\t\t\ttiny_result.done = false;\u000A\t\t\t\t\t\t\ttiny_result.seq_num = current_kmer.seq_num;\u000A\t\t\t\t\t\t\ttiny_result.kmer_num = current_kmer.kmer_num;\u000A\t\t\t\t\t\t\ttiny_result.hash_num = i;\u000A\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t\t//hash2bank_pipes::PipeAt<i>::write(tiny_result);\u000A\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t\tfpga_tools::UnrolledLoop<8>([&](auto k) { //hate that this is hard coded\u000A\t\t\t\t\t\t\t\tif(bank_num == k){\u000A\t\t\t\t\t\t\t\t\thash2bank_pipes::PipeAt<i * (BANKS/H) + k>::write(tiny_result);\u000A\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t});\u000A\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\u000A\t\t\t\t\t\u000A\t\t\t\t\t\thash_result  done_signal;\u000A\t\t\t\t\t\tdone_signal.done = true;\u000A\t\t\t\t\t\tfpga_tools::UnrolledLoop<8>([&](auto k) { //hate that this is hard coded\u000A\t\t\t\t\t\t\thash2bank_pipes::PipeAt<i*(BANKS/H) + k>::write(done_signal);\u000A\t\t\t\t\t\t});\u000A\t\t\t\t\t}\u000A\t\t\t\t});\u000A\t\t\t});\u000A\t\t});\u000A         \u000A         //special case for the last one\u000A        q.submit([&](handler& h) {\u000A\t\t\th.single_task([=]()[[intel::kernel_args_restrict]]{\u000A\t\t\t\t//out << \"This is hashing kernel\" << sycl::endl;\u000A\t\t\t\tlong long unsigned int top_bits = (M >> 1) + (M >> 2) + (M >> 3);\u000A\t\t\t\tfor (int loop = 0; loop < 2; loop++){\u000A\t\t\t\t\tfor (int j = 0; j < total_kmers; j++){\u000A\t\t\t\t\t\tkmer_data current_kmer = kmer2hash_pipes::PipeAt<3>::read();\u000A\t\t\t\t\t\t//for (int i =0; i < H; i++){\u000A\t\t\t\t\t\t//unsigned int result = MurmurHash2(&current_kmer.kmer, i) & (unsigned long long int)(M-1);\u000A\t\t\t\t\t\tunsigned long long int result = MurmurHash64A(&current_kmer.kmer, 3) ;\u000A\u000A\t\t\t\t\t\t//result &= (unsigned long long int)(M-1);\u000A\t\t\t\t\t\tresult = result % top_bits; //special case that lets us reuse the top_bits variable\u000A\t\t\t\t\t\tshort bank_num = (result & top_bits) >> shift;\u000A\t\t\t\t\t\thash_result  tiny_result;\u000A\t\t\t\t\t\ttiny_result.result = (result & ((M-1) >> 3)); //this gets sent to the bank, strip top 2 bits\u000A\t\t\t\t\t\t//tiny_result.result = result;\u000A\t\t\t\t\t\ttiny_result.done = false;\u000A\t\t\t\t\t\ttiny_result.seq_num = current_kmer.seq_num;\u000A\t\t\t\t\t\ttiny_result.kmer_num = current_kmer.kmer_num;\u000A\t\t\t\t\t\ttiny_result.hash_num = 3;\u000A\u000A\t\t\t\t\t\t//hash2bank_pipes::PipeAt<i>::write(tiny_result);\u000A\u000A\t\t\t\t\t\tfpga_tools::UnrolledLoop<7>([&](auto k) { //hate that this is hard coded\u000A\t\t\t\t\t\t\tif(bank_num == k){\u000A\t\t\t\t\t\t\t\thash2bank_pipes::PipeAt<3 * (BANKS/H) + k>::write(tiny_result);\u000A\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t});\u000A\u000A\u000A\t\t\t\t\t}\u000A\u000A\u000A\t\t\t\t\thash_result  done_signal;\u000A\t\t\t\t\tdone_signal.done = true;\u000A\t\t\t\t\tfpga_tools::UnrolledLoop<7>([&](auto k) { //hate that this is hard coded\u000A\t\t\t\t\t\thash2bank_pipes::PipeAt<3*(BANKS/H) + k>::write(done_signal);\u000A\t\t\t\t\t});\u000A\t\t\t\t}\u000A\t\t\t});\u000A\t\t});\u000A        \u000A\t\tfpga_tools::UnrolledLoop<BF_BANKS>([&](auto i) {\u000A\t\t\tauto acc_bf = q.submit([&](handler& h) {\u000A\t\t\t\taccessor bf_accessor(bank_bufs[i][0], h, read_write, ext::oneapi::accessor_property_list{sycl::ext::oneapi::no_alias, ext::intel::buffer_location<i+1>});\u000A\t\t\t\t//accessor a_found(found_buf, h, write_only, ext::oneapi::accessor_property_list{sycl::ext::oneapi::no_alias, ext::intel::buffer_location<2>, no_init});\u000A\t\t\t\th.single_task([=]()[[intel::kernel_args_restrict]]{\u000A\t\t\t\t\tbool done = false;\u000A\t\t\t\t\tbool success;\u000A\t\t\t\t\tfor (int loop = 0; loop < 2; loop++){ //one loop for composition, next for query\u000A\t\t\t\t\t\tdone = false;\u000A\t\t\t\t\t\twhile(!done){\u000A\t\t\t\t\t\t\t//unsigned int result = res_pipe::read();\u000A\t\t\t\t\t\t\thash_result read_result = hash2bank_pipes::PipeAt<i>::read(success);\u000A\t\t\t\t\t\t\t//hash_result read_result = hash2bank_pipes::PipeAt<i>::read();\u000A\t\t\t\t\t\t\tif (success){\u000A\t\t\t\t\t\t\t\tdone = read_result.done;\u000A\t\t\t\t\t\t\t\tif(!done){\u000A\t\t\t\t\t\t\t\t\tshort lower = (read_result.result & 3) << 1;\u000A\t\t\t\t\t\t\t\t\tunsigned int upper = read_result.result >> 2;\u000A\t\t\t\t\t\t\t\t\tchar bf_byte = bf_accessor[upper];  //should split up this read and the write\u000A\t\t\t\t\t\t\t\t\tunsigned int idx = 1 << lower;\u000A\u000A\t\t\t\t\t\t\t\t\tif(loop == 0){ //composition stage\u000A\u000A\t\t\t\t\t\t\t\t\t\tif((bf_byte & idx) != 0){\u000A\t\t\t\t\t\t\t\t\t\t\tif((bf_byte & (idx << 1)) == 0){ //only write if we haven't already\u000A\t\t\t\t\t\t\t\t\t\t\t\tbf_byte = bf_byte | (idx << 1);\u000A\t\t\t\t\t\t\t\t\t\t\t\tbf_accessor[upper] |= bf_byte; //changed this, might be issue with atomic op\u000A\t\t\t\t\t\t\t\t\t\t\t\t//bf_accessor[upper] = bf_byte;\u000A\t\t\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t\t\telse{ //if index is empty then write one to it\u000A\t\t\t\t\t\t\t\t\t\t\tbf_byte = bf_byte | idx;\u000A\t\t\t\t\t\t\t\t\t\t\tbf_accessor[upper] |= bf_byte; //changed for same reason\u000A\t\t\t\t\t\t\t\t\t\t\t//bf_accessor[upper] = bf_byte;\u000A\t\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t\telse{ //the query stage\u000A\u000A\t\t\t\t\t\t\t\t\t\tbank_query q;\u000A\u000A\u000A\t\t\t\t\t\t\t\t\t\tq.found = (bf_byte & (idx << 1)) != 0;\u000A\t\t\t\t\t\t\t\t\t\tq.seq_num = read_result.seq_num;\u000A\t\t\t\t\t\t\t\t\t\tq.kmer_num = read_result.kmer_num;\u000A\u000A\t\t\t\t\t\t\t\t\t\tbank2comp_pipes::PipeAt<i>::write(q);\u000A\u000A\t\t\t\t\t\t\t\t\t\t//a_found[read_result.seq_num].found[read_result.kmer_num] = a_found[read_result.seq_num].found[read_result.kmer_num] & ((bf_accessor[upper] & (idx << 1)) != 0);\u000A\t\t\t\t\t\t\t\t\t\t//a_found[read_result.seq_num].seen++;\u000A\u000A\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t}\u000A\t\t\t\t\t}\u000A\t\t\t\t});\u000A\t\t\t});\u000A\t\t});\u000A\t\t\u000A\t\t//need a kernel here to collect the query data from the banks\u000A        //Collect the queries for a specific hash function, then pass that on to the global compilation\u000A        fpga_tools::UnrolledLoop<3>([&](auto i) {\u000A            q.submit([&](handler& h) {\u000A                h.single_task([=]()[[intel::kernel_args_restrict]]{\u000A                    \u000A                    //out << \"This is the compiler kernel\" << sycl::endl;\u000A                    bool early[8] = { 0 }; // array to check if one banks is ahead of the others and needs to wait\u000A                    bank_query early_qs[8];\u000A                    bank_query current_q;\u000A                    for (int j = 0; j < total_valid_reads; j++){\u000A                        int L = len2comp_pipes::PipeAt<i>::read();\u000A                        //std::bitset<MAX_SEQ_L - K + 1> found = 0;\u000A\t\t\t\t\t\tstd::bitset<2*MAX_SEQ_L> found = 0;\u000A                        \u000A                        for (int k = 0; k < L - K + 1; k++){\u000A                            bool success = false;\u000A                            int index = k & 7; //start at a new bank each time\u000A                            while(!success){//check pipes until there one is read, need to make sure it belongs to the correct sequence\u000A                                \u000A                                fpga_tools::UnrolledLoop<8>([&](auto n) {\u000A\u000A                                    if (index == n && !success) {\u000A                                    //if (!success) {\u000A                                        if (early[n]){//Shouldn't read from this pipe, already read one early\u000A                                            if(early_qs[n].seq_num == j){ //no longer early\u000A                                                current_q = early_qs[n];\u000A                                                early[n] = false;\u000A                                                success = true;\u000A                                                found[current_q.kmer_num] = current_q.found; //add it to the query results\u000A                                            }\u000A                                            //else{\u000A                                            //    index++;\u000A                                            //}\u000A\u000A                                        }\u000A                                        else{ //if not early then its safe to try and read from that pipe\u000A                                            current_q = bank2comp_pipes::PipeAt<i*(BANKS/H) + n>::read(success);\u000A                                            if(success){//read result from pipe\u000A                                                //success = true; //dummy line just to be safe\u000A                                                if (current_q.seq_num != j){ // oops its early\u000A                                                    early_qs[n] = current_q;\u000A                                                    early[n] = true;\u000A                                                    success = false;\u000A                                                }\u000A                                                else{ //add result to sequence bitset\u000A                                                    found[current_q.kmer_num] = current_q.found;\u000A                                                }\u000A                                            }\u000A                                            //else{ // no read :/\u000A                                                //index++;\u000A                                            //}\u000A                                        }\u000A                                    }\u000A                                    \u000A                                    index++;\u000A                                    \u000A                                    //index++;\u000A                                });\u000A                                \u000A                                index = 0;\u000A                                \u000A                            }\u000A                        }\u000A                        \u000A                        //finished reading all query results for this sequence, write these partial results to compiler\u000A                        partial_query q;\u000A                        q.found = found;\u000A                        q.seq_num = j;\u000A                        comp2final_pipes::PipeAt<i>::write(q);\u000A                    }\u000A                        \u000A                });\u000A            });\u000A        });\u000A         //special case for the final hash function\u000A         q.submit([&](handler& h) {\u000A\t\t\th.single_task([=]()[[intel::kernel_args_restrict]]{\u000A\u000A\t\t\t\t//out << \"This is the compiler kernel\" << sycl::endl;\u000A\t\t\t\tbool early[7] = { 0 }; // array to check if one banks is ahead of the others and needs to wait\u000A\t\t\t\tbank_query early_qs[7];\u000A\t\t\t\tbank_query current_q;\u000A\t\t\t\tfor (int j = 0; j < total_valid_reads; j++){\u000A\t\t\t\t\tint L = len2comp_pipes::PipeAt<3>::read();\u000A\t\t\t\t\t//std::bitset<MAX_SEQ_L - K + 1> found = 0;\u000A\t\t\t\t\tstd::bitset<2*MAX_SEQ_L> found = 0;\u000A\u000A\t\t\t\t\tfor (int k = 0; k < L - K + 1; k++){\u000A\t\t\t\t\t\tbool success = false;\u000A\t\t\t\t\t\tint index = k % 7; //start at a new bank each time\u000A\t\t\t\t\t\twhile(!success){//check pipes until there one is read, need to make sure it belongs to the correct sequence\u000A\u000A\t\t\t\t\t\t\tfpga_tools::UnrolledLoop<7>([&](auto n) {\u000A\u000A\t\t\t\t\t\t\t\tif (index == n && !success) {\u000A\t\t\t\t\t\t\t\t//if (!success) {\u000A\t\t\t\t\t\t\t\t\tif (early[n]){//Shouldn't read from this pipe, already read one early\u000A\t\t\t\t\t\t\t\t\t\tif(early_qs[n].seq_num == j){ //no longer early\u000A\t\t\t\t\t\t\t\t\t\t\tcurrent_q = early_qs[n];\u000A\t\t\t\t\t\t\t\t\t\t\tearly[n] = false;\u000A\t\t\t\t\t\t\t\t\t\t\tsuccess = true;\u000A\t\t\t\t\t\t\t\t\t\t\tfound[current_q.kmer_num] = current_q.found; //add it to the query results\u000A\t\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t\t\t//else{\u000A\t\t\t\t\t\t\t\t\t\t//    index++;\u000A\t\t\t\t\t\t\t\t\t\t//}\u000A\u000A\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t\telse{ //if not early then its safe to try and read from that pipe\u000A\t\t\t\t\t\t\t\t\t\tcurrent_q = bank2comp_pipes::PipeAt<3*(BANKS/H) + n>::read(success);\u000A\t\t\t\t\t\t\t\t\t\tif(success){//read result from pipe\u000A\t\t\t\t\t\t\t\t\t\t\t//success = true; //dummy line just to be safe\u000A\t\t\t\t\t\t\t\t\t\t\tif (current_q.seq_num != j){ // oops its early\u000A\t\t\t\t\t\t\t\t\t\t\t\tearly_qs[n] = current_q;\u000A\t\t\t\t\t\t\t\t\t\t\t\tearly[n] = true;\u000A\t\t\t\t\t\t\t\t\t\t\t\tsuccess = false;\u000A\t\t\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t\t\t\telse{ //add result to sequence bitset\u000A\t\t\t\t\t\t\t\t\t\t\t\tfound[current_q.kmer_num] = current_q.found;\u000A\t\t\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t\t\t//else{ // no read :/\u000A\t\t\t\t\t\t\t\t\t\t\t//index++;\u000A\t\t\t\t\t\t\t\t\t\t//}\u000A\t\t\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t\t\t}\u000A\u000A\t\t\t\t\t\t\t\tindex++;\u000A\u000A\t\t\t\t\t\t\t\t//index++;\u000A\t\t\t\t\t\t\t});\u000A\u000A\t\t\t\t\t\t\tindex = 0;\u000A\u000A\t\t\t\t\t\t}\u000A\t\t\t\t\t}\u000A\u000A\t\t\t\t\t//finished reading all query results for this sequence, write these partial results to compiler\u000A\t\t\t\t\tpartial_query q;\u000A\t\t\t\t\tq.found = found;\u000A\t\t\t\t\tq.seq_num = j;\u000A\t\t\t\t\tcomp2final_pipes::PipeAt<3>::write(q);\u000A\t\t\t\t}\u000A\u000A\t\t\t});\u000A\t\t});\u000A        \u000A\t\t\u000A\u000A\t\t\u000A\t\t //Get results from all banks and combine to form the final query results\u000A        //{buffer<query, 1> found_buf{all_qs, range{(unsigned long long)total_valid_reads}, ext::oneapi::accessor_property_list{sycl::ext::oneapi::no_alias, ext::intel::buffer_location<BANKS-1>}}; \u000A        q.submit([&](handler& h) {\u000A            //accessor a_found{found_buf, h, read_write, no_init};\u000A\t\t\taccessor a_found(seq_buf, h, read_write, ext::oneapi::accessor_property_list{sycl::ext::oneapi::no_alias, ext::intel::buffer_location<0>});\u000A            h.single_task([=]()[[intel::kernel_args_restrict]]{\u000A                partial_query curr_results;\u000A\t\t\t\tsequence full_query;\u000A                for (int j = 0; j < total_valid_reads * H; j++){ //might be an issue here, double check this line\u000A                    bool success = false;\u000A                    int index = j & (H - 1);\u000A                    while(!success){\u000A                        fpga_tools::UnrolledLoop<H>([&](auto i) {\u000A                            if (index == i && !success){\u000A                                curr_results = comp2final_pipes::PipeAt<i>::read(success);\u000A                            }\u000A                            index++;\u000A                        });\u000A                        index = 0;\u000A                    }\u000A\t\t\t\t\tfull_query = a_found[curr_results.seq_num];\u000A\u000A                    full_query.seq = full_query.seq & curr_results.found;\u000A                    full_query.L++;\u000A                    //a_found[curr_results.seq_num].seen++;\u000A\t\t\t\t\ta_found[curr_results.seq_num] = full_query;\u000A                } \u000A            });\u000A        });\u000A        }\u000A\t\t\u000A        compose_finished = true;\u000A        //q.wait();\u000A\u000A        // Put Through Database\u000A        \u000A        std::unordered_map<std::bitset<2*K>, int> *hash_table = new std::unordered_map<std::bitset<2*K>, int>;\u000A        \u000A        \u000A\u000A        \u000A        for (int j = 0; j < total_valid_reads; j++){\u000A            while( H != all_reads_dev[j].L){};\u000A            for(int i = 0; i <  all_reads[j].L - K + 1; i++){\u000A                if(all_reads_dev[j].seq[i] == 1){\u000A                    std::bitset<2*K> kmer_bits = 0;\u000A                    for(int n = 0; n < K; n++){\u000A                        kmer_bits[n << 1] = all_reads[j].seq[(i + n) << 1];\u000A                        kmer_bits[(n << 1) + 1] = all_reads[j].seq[((i + n) << 1)+1];\u000A                    }\u000A                    if (kmer_bits[(K << 1) -1]){\u000A                        kmer_bits.flip();\u000A                    }\u000A                    //unsigned long long int kmer_as_int = kmer_bits.to_ullong();\u000A                    std::unordered_map<std::bitset<2*K>, int>::iterator it = hash_table->find(kmer_bits);\u000A                    if (it != hash_table->end()) {\u000A                            it->second++;\u000A                    }\u000A                    else{\u000A                        hash_table->insert({kmer_bits, 1});\u000A                    }\u000A                }\u000A            }\u000A        }\u000A        \u000A\u000A\u000A        long long unsigned int distinct_hashed = (long long unsigned int)hash_table->size();\u000A\u000A        \u000A        //remove false positives\u000A        std::unordered_map<std::bitset<2*K>, int>::iterator itr; \u000A        for(itr = hash_table->begin(); itr !=  hash_table->end();){\u000A            if (itr->second == 1){\u000A                itr = hash_table->erase(itr);\u000A            }\u000A            else{\u000A                ++itr;\u000A            }\u000A        }\u000A        auto end_sw = std::chrono::high_resolution_clock::now();\u000A        \u000A        //calc the false positive rate\u000A        \u000A        double fp = distinct_hashed - hash_table->size();\u000A        \u000A\u000A        double kmers_in_table = 0;\u000A        std::unordered_map<std::bitset<2*K>, int>::iterator itr2; \u000A        for(itr2 = hash_table->begin(); itr2 !=  hash_table->end();){\u000A            kmers_in_table += itr2->second;\u000A            itr2++;\u000A        }\u000A        double fp_rate = fp / (total_kmers - kmers_in_table);\u000A        fp_rate = fp_rate * 100; \u000A        \u000A        printf(\"\\nNumber of distinct hashed k_mers: %llu\", distinct_hashed);\u000A        printf(\"\\nNumber remaining after removing fp: %llu\", (long long unsigned int)hash_table->size());\u000A        printf(\"\\nFalse positive rate: %f %%\", fp_rate);\u000A        printf(\"\\nNumber of valid reads: %d\", total_valid_reads);\u000A        printf(\"\\nNumber of nucleotides: %llu\", total_nucleotides);\u000A        //print_hash_lookup_table(hash_table);\u000A        // Compute total time of execution\u000A        auto dur_sw = std::chrono::duration_cast<std::chrono::nanoseconds>(end_sw - start_sw);\u000A        std::cout << \"\\nExecution Time: \" << dur_sw.count() / 1000000000.0 << \" s\" << std::endl;\u000A\u000A        delete hash_table;\u000A        \u000A        \u000A        \u000A        //free((void *)bf, q);\u000A        free(all_reads);\u000A\t\tfree(all_reads_dev);\u000A        //free(all_qs);\u000A        free(kmer_len);\u000A       \u000A        printf(\"\\n\");\u000A        return 0;\u000A    }\u000A    catch (sycl::exception const& e) {\u000A    // Catches exceptions in the host code\u000A    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\u000A\u000A    // Most likely the runtime couldn't find FPGA hardware!\u000A    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\u000A      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\u000A                   \"system has a correctly configured FPGA board.\\n\";\u000A      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\u000A      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\u000A                   \"-DFPGA_EMULATOR.\\n\";\u000A    }\u000A    std::terminate();\u000A  }\u000A\u000A}\u000A\u000A\u000A"}, {"path":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/unrolled_loop.hpp", "name":"unrolled_loop.hpp", "has_active_debug_locs":false, "absName":"/ihome/ageorge/opl1/Documents/k_mers/kmer_testing/src/unrolled_loop.hpp", "content":"#ifndef __UNROLLEDLOOP_HPP__\u000A#define __UNROLLEDLOOP_HPP__\u000A\u000A#include <type_traits>\u000A#include <utility>\u000A\u000A#include \"metaprogramming_utils.hpp\"\u000A\u000Anamespace fpga_tools {\u000A///////////////////////////////////////////////////////////////////////////////\u000A//\u000A// Example usage for UnrolledLoop constexpr:\u000A//\u000A// Base\u000A//    UnrolledLoop(std::integer_sequence<int,5,2,7,8>{},[&](auto i) {\u000A//      /* i = 5,2,7,8 */\u000A//    });\u000A//\u000A// Case A\u000A//    UnrolledLoop<10>([&](auto i) {\u000A//      /* i = 0,1,...,9 */\u000A//    });\u000A//\u000A// Case B\u000A//    UnrolledLoop<10>([&](auto i) {\u000A//      /* i = 0,1,...,9 */\u000A//    });\u000A//\u000A// Case C\u000A//    UnrolledLoop<char, 1, 10>([&](auto i) {\u000A//      /* i = 1,2,...,9 */\u000A//    });\u000A//    UnrolledLoop<char, 10, 1>([&](auto i) {\u000A//      /* i = 10,9,...,2 */\u000A//    });\u000A//\u000A// Case D\u000A//    UnrolledLoop<1, 10>([&](auto i) {\u000A//      /* i = 1,2,...,9 */\u000A//    });\u000A//    UnrolledLoop<10, 1>([&](auto i) {\u000A//      /* i = 10,9,...,2 */\u000A//    });\u000A//\u000A///////////////////////////////////////////////////////////////////////////////\u000A\u000A//\u000A// Base implementation\u000A// Templated on:\u000A//    ItType    - the type of the iterator (size_t, int, char, ...)\u000A//    ItType... - the indices to iterate on\u000A//    F         - the function to run for each index (i.e. the lambda)\u000A//\u000Atemplate <class ItType, ItType... inds, class F>\u000Aconstexpr void UnrolledLoop(std::integer_sequence<ItType, inds...>, F&& f) {\u000A  (f(std::integral_constant<ItType, inds>{}), ...);\u000A}\u000A\u000A//\u000A// Convience implementation (A)\u000A// performs UnrolledLoop in range [0,n) with iterator of type ItType\u000A//\u000Atemplate <class ItType, ItType n, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(std::make_integer_sequence<ItType, n>{}, std::forward<F>(f));\u000A}\u000A\u000A//\u000A// Convenience implementation (B)\u000A// performs UnrolledLoop in range [0,n) with an iterator of type std::size_t\u000A//\u000Atemplate <std::size_t n, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(std::make_index_sequence<n>{}, std::forward<F>(f));\u000A}\u000A\u000A//\u000A// Convenience implementation (C)\u000A// performs UnrolledLoop from start...end with an iterator of type ItType\u000A// NOTE:  start is INCLUSIVE, end is EXCLUSIVE\u000A// NOTE:  if start<=end, sequence is start,start+1,...,end-1\u000A//        if end<=start, sequence is start,start-1,...,end+1\u000A//\u000Atemplate <class ItType, ItType start, ItType end, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(make_integer_range<ItType, start, end>{}, std::forward<F>(f));\u000A}\u000A\u000A//\u000A// Convenience implementation (D)\u000A// performs UnrolledLoop from start...end with an iterator of type size_t\u000A// NOTE:  start is INCLUSIVE, end is EXCLUSIVE\u000A// NOTE:  if start<=end, sequence is start,start+1,...,end-1\u000A//        if end<=start, sequence is start,start-1,...,end+1\u000A//\u000Atemplate <std::size_t start, std::size_t end, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(make_index_range<start, end>{}, std::forward<F>(f));\u000A}\u000A\u000A\u000A}  // namespace fpga_tools\u000A\u000A#endif /* __UNROLLEDLOOP_HPP__ */"}]